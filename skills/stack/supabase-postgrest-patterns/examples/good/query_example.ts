/**
 * Good Supabase PostgREST query example.
 *
 * Demonstrates:
 * - Typed queries with generated Database types
 * - Resource embedding (joins) to avoid N+1
 * - Explicit error handling
 * - Pagination with count
 * - RPC for complex operations
 * - Specific column selection
 */

import { createClient } from "@supabase/supabase-js";

// ---------------------------------------------------------------------------
// Types (generated by supabase gen types typescript)
// ---------------------------------------------------------------------------

interface Database {
  public: {
    Tables: {
      invoices: {
        Row: {
          id: string;
          tenant_id: string;
          customer_id: string;
          status: "draft" | "sent" | "paid" | "overdue" | "cancelled";
          created_at: string;
          updated_at: string;
          metadata: Record<string, unknown>;
        };
        Insert: Omit<Database["public"]["Tables"]["invoices"]["Row"], "id" | "created_at" | "updated_at">;
        Update: Partial<Database["public"]["Tables"]["invoices"]["Insert"]>;
      };
      customers: {
        Row: {
          id: string;
          tenant_id: string;
          name: string;
          email: string;
        };
      };
      line_items: {
        Row: {
          id: string;
          invoice_id: string;
          description: string;
          quantity: number;
          unit_price: number;
        };
      };
    };
    Functions: {
      calculate_invoice_total: {
        Args: { p_invoice_id: string };
        Returns: { subtotal: number; tax: number; total: number }[];
      };
    };
  };
}

// ---------------------------------------------------------------------------
// Typed client
// ---------------------------------------------------------------------------

const supabase = createClient<Database>(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_ANON_KEY!,
);

// ---------------------------------------------------------------------------
// Error handling
// ---------------------------------------------------------------------------

class SupabaseQueryError extends Error {
  constructor(
    message: string,
    public readonly pgError: { message: string; code: string },
  ) {
    super(`${message}: ${pgError.message} (code: ${pgError.code})`);
    this.name = "SupabaseQueryError";
  }
}

// ---------------------------------------------------------------------------
// Paginated list with resource embedding
// ---------------------------------------------------------------------------

interface PaginatedResult<T> {
  items: T[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}

interface InvoiceSummary {
  id: string;
  status: string;
  created_at: string;
  customer: { id: string; name: string } | null;
  line_items: { id: string; description: string; quantity: number; unit_price: number }[];
}

const DEFAULT_PAGE_SIZE = 50;

async function getInvoices(
  tenantId: string,
  page: number = 1,
  pageSize: number = DEFAULT_PAGE_SIZE,
): Promise<PaginatedResult<InvoiceSummary>> {
  const from = (page - 1) * pageSize;
  const to = from + pageSize - 1;

  // Single query with resource embedding — no N+1!
  const { data, error, count } = await supabase
    .from("invoices")
    .select(
      `
      id,
      status,
      created_at,
      customer:customers (
        id,
        name
      ),
      line_items (
        id,
        description,
        quantity,
        unit_price
      )
    `,
      { count: "exact" },
    )
    .eq("tenant_id", tenantId)
    .order("created_at", { ascending: false })
    .range(from, to);

  // Always check for errors
  if (error) {
    throw new SupabaseQueryError("Failed to fetch invoices", error);
  }

  return {
    items: (data ?? []) as unknown as InvoiceSummary[],
    total: count ?? 0,
    page,
    pageSize,
    hasMore: (count ?? 0) > page * pageSize,
  };
}

// ---------------------------------------------------------------------------
// Single record with error handling
// ---------------------------------------------------------------------------

async function getInvoiceById(invoiceId: string): Promise<InvoiceSummary> {
  const { data, error } = await supabase
    .from("invoices")
    .select(
      `
      id,
      status,
      created_at,
      customer:customers (id, name),
      line_items (id, description, quantity, unit_price)
    `,
    )
    .eq("id", invoiceId)
    .single(); // Expects exactly one row — returns 404 if not found

  if (error) {
    throw new SupabaseQueryError("Failed to fetch invoice", error);
  }

  return data as unknown as InvoiceSummary;
}

// ---------------------------------------------------------------------------
// Insert with typed input
// ---------------------------------------------------------------------------

async function createInvoice(
  tenantId: string,
  customerId: string,
): Promise<{ id: string }> {
  const { data, error } = await supabase
    .from("invoices")
    .insert({
      tenant_id: tenantId,
      customer_id: customerId,
      status: "draft",
      metadata: {},
    })
    .select("id")
    .single();

  if (error) {
    throw new SupabaseQueryError("Failed to create invoice", error);
  }

  return data;
}

// ---------------------------------------------------------------------------
// RPC for complex operations
// ---------------------------------------------------------------------------

async function getInvoiceTotal(
  invoiceId: string,
): Promise<{ subtotal: number; tax: number; total: number }> {
  const { data, error } = await supabase.rpc("calculate_invoice_total", {
    p_invoice_id: invoiceId,
  });

  if (error) {
    throw new SupabaseQueryError("Failed to calculate total", error);
  }

  // RPC returns an array for TABLE return types
  if (!data || data.length === 0) {
    throw new Error(`No line items found for invoice ${invoiceId}`);
  }

  return data[0];
}

// ---------------------------------------------------------------------------
// Filtered query with multiple conditions
// ---------------------------------------------------------------------------

async function getOverdueInvoices(
  tenantId: string,
  minAmount: number,
): Promise<InvoiceSummary[]> {
  const { data, error } = await supabase
    .from("invoices")
    .select(
      `
      id,
      status,
      created_at,
      customer:customers (id, name),
      line_items (id, description, quantity, unit_price)
    `,
    )
    .eq("tenant_id", tenantId)
    .eq("status", "overdue")
    .gt("created_at", new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())
    .order("created_at", { ascending: true });

  if (error) {
    throw new SupabaseQueryError("Failed to fetch overdue invoices", error);
  }

  return (data ?? []) as unknown as InvoiceSummary[];
}

export {
  getInvoices,
  getInvoiceById,
  createInvoice,
  getInvoiceTotal,
  getOverdueInvoices,
};
